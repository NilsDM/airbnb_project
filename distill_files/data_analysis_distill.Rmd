---
title: "Airbnb Data Analytics"
description: | 
  Answering several data analysis questions using our RSQLite database setup in the previous post
author:
  - name: Nils Dosaj Mikkelsen, Jose Lama
    url: https://example.com/norajones 
    
date: "`r Sys.Date()`"
output: 
  distill::distill_article:
    toc: true
    toc_depth: 3
    code_folding: FALSE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction

In this post, we demonstrate how to answer a number of questions related to room listing type and host info using our newly created RSQLite database.

## Questions

We answer the following 11 questions:

### Room Listing

  1. What is the most common room type available?
  2. What is the top and bottom 10 property type based on average price?
  3. What is the top and bottom 10 property type based on review score?
  4. What is the most common amenities provided?
  5. Is there any correlation between room price and the review score?
  6. Room listing geographical distribution

### Host

  7. Who are the top 10 host based on revenue?
  8. Is there any difference in review score between superhost and normal host? 
  9. Is there any difference in response rate between superhost and normal host?
  10. What is the most commonly verified host information?
  11. How has the number of hosts joining airbnb increased/decreased overtime?

## Libraries, Database Connection and Functions

### Libraries

First, we must load the necessary libraries required for our data analysis and connect to our database.

```{r}
# Libraries
library(DBI) 
library(RSQLite)
library(tidyr)
library(tibble)
library(dbplyr)
library(dplyr, warn.conflicts = FALSE)
library(leaflet)
library(lubridate)
library(ggplot2)
library(gridExtra)
library(tidyquant)
library(zoo)
```

### Database Connection

Next, we connect to our database that we set up in the previous post

```{r}
con <- dbConnect(RSQLite::SQLite(), "airdb.SQLite")
```


### The `build_airbnb_database()` Function

If you have not yet set up the require database, you may use the `build_airbnb_database()` function to do so for you. Note that this function leverages the `remove_old_database()` and `insert_to_sql()` functions defined in the previous post.

```{r, code_folding=TRUE}
build_airbnb_database <- function(con, listing_data, remove_old_database = FALSE){
    
    #################### Remove Existing database
    if(remove_old_database == TRUE){
        remove_live_database(con)
    }

    #################### Deal with NA values 
    listing_data <- 
        listing_data %>% 
        
        # Convert dates to characters for NA values
        mutate(last_scraped = as.character(last_scraped),
               host_since = as.character(host_since),
               calendar_last_scraped = as.character(calendar_last_scraped),
               first_review = as.character(first_review),
               last_review = as.character(last_review),
               ) %>% 
        
        # Homogenize NA values
        #*# Taken from: https://rpubs.com/Argaadya/create_table_sql
        mutate_all(function(x) ifelse(x == "" | x == "None" | x == "N/A", NA, x)) %>%  #*#
        # mutate_all(function(x) ifelse(is.na(x), "NULL", x)) %>% 
        
        # Convert character strings back to date type
        mutate(last_scraped = as.Date(last_scraped),
               host_since = as.Date(host_since),
               calendar_last_scraped = as.Date(calendar_last_scraped),
               first_review = as.Date(first_review),
               last_review = as.Date(last_review)) 
    
    
    #################### Extract host data
    host_data <- listing_data %>% 
        select(host_id:host_identity_verified, 
               calculated_host_listings_count:calculated_host_listings_count_shared_rooms)
    
    
    #################### Remove duplicate values
    host_data <- host_data %>% distinct()
    
    
    #################### Convert dates
    # Note that this will need to converted back to type = date for analysis
    host_data  <- host_data %>% mutate(host_since = as.character(host_since)) 
    
    
    #################### Clean host verification column
    host_data <- 
        host_data %>% 
        mutate(host_verifications = str_remove_all(host_verifications, "[\\'\\[\\]]"))
    
    
    #################### Create table for host info
    query <- "CREATE TABLE host_info(
        host_id INT, 
        host_url VARCHAR(50), 
        host_name VARCHAR(100), 
        host_since VARCHAR(50),
        host_location VARCHAR(500), 
        host_about VARCHAR(10000),
        host_response_time VARCHAR(50),
        host_response_rate VARCHAR(50),
        host_acceptance_rate VARCHAR(50),
        host_is_superhost BOOLEAN,
        host_thumbnail_url VARCHAR(500),
        host_picture_url VARCHAR(500),
        host_neighbourhood VARCHAR(50),
        host_listings_count INT,
        host_total_listings_count INT,
        host_verifications VARCHAR(500),
        host_has_profile_pic BOOLEAN,
        host_identity_verified BOOLEAN,
        calculated_host_listings_count INT, 
        calculated_host_listings_count_entire_homes INT,
        calculated_host_listings_count_private_rooms INT,
        calculated_host_listings_count_shared_rooms INT,
        PRIMARY KEY(host_id)
        )"
    
    
    #################### Load host_info table
    dbSendQuery(con, query)
    
    
    #################### Check schema
    res <- dbSendQuery(con, "PRAGMA table_info([host_info]);")
    fetch(res)  
    dbClearResult(res)
    
    
    #################### Insert data into host_info table
    insert_to_sql(con, "host_info", host_data)
    
    
    ####################Listing table Processing####################
    
    # listing_data %>% view() 
    listing_data %>% glimpse()
    
    #################### Remove host_data columns
    listing_data <- listing_data %>% 
        select( - names(host_data)[-1])
    
    
    #################### Remove extraneous columns 
    listing_data <- listing_data %>% 
        select(-c(license, calendar_updated, bathrooms, scrape_id))
    
    
    #################### Remove dollar signs from price column
    listing_data <- listing_data %>% 
        mutate(price = str_remove_all(price, "[$,]") %>% 
                   as.numeric()
        )
    
    
    #################### Transform amenities and host verification column
    listing_data <- listing_data %>% 
        mutate(amenities = str_remove_all(amenities, "[\"\\'\\[\\]]"))
    
    
    listing_data %>% glimpse()
    
    #################### Convert dates to character
    listing_data <- 
        listing_data %>% 
        mutate(last_scraped          = as.character(last_scraped), 
               calendar_last_scraped = as.character(calendar_last_scraped),
               first_review          = as.character(first_review),
               last_review           = as.character(last_review))
    
    
    #################### Create listing table
    query_2 <- "CREATE TABLE listing (
        id INT,
        listing_url VARCHAR(100),
        last_scraped VARCHAR(50),
        name VARCHAR(500),
        description VARCHAR(2000),
        neighborhood_overview VARCHAR(2000),
        picture_url VARCHAR(500),
        host_id INT,
        neighbourhood VARCHAR(100),
        neighbourhood_cleansed VARCHAR(100),
        neighbourhood_group_cleansed VARCHAR(100),
        latitude DECIMAL(25,18),
        longitude DECIMAL(25, 18),
        property_type VARCHAR(100),
        room_type VARCHAR(100),
        accommodates INT,
        bathrooms_text VARCHAR(100),
        bedrooms INT,
        beds INT,
        amenities VARCHAR(2000),
        price DECIMAL(15, 5),
        minimum_nights INT,
        maximum_nights INT,
        minimum_minimum_nights INT,
        maximum_minimum_nights INT,
        minimum_maximum_nights INT,
        maximum_maximum_nights INT,
        minimum_nights_avg_ntm DECIMAL(16, 5),
        maximum_nights_avg_ntm DECIMAL(16, 5),
        has_availability BOOLEAN,
        availability_30 INT,
        availability_60 INT,
        availability_90 INT,
        availability_365 INT,
        calendar_last_scraped VARCHAR(50),
        number_of_reviews INT,
        number_of_reviews_ltm INT,
        number_of_reviews_l30d INT,
        first_review VARCHAR(50),
        last_review VARCHAR(50),
        review_scores_rating DECIMAL(10, 5),
        review_scores_accuracy DECIMAL(10, 5),
        review_scores_cleanliness DECIMAL(10, 5),
        review_scores_checkin DECIMAL(10, 5),
        review_scores_communication DECIMAL(10, 5),
        review_scores_location DECIMAL(10, 5),
        review_scores_value DECIMAL(10, 5),
        instant_bookable BOOLEAN,
        reviews_per_month DECIMAL(10, 5),
        PRIMARY KEY(id),
        FOREIGN KEY(host_id) REFERENCES host_info(host_id)
    )"
    
    
    #################### Insert listing table into database
    dbSendQuery(con, query_2)
    
    
    #################### Insert data into listing table
    insert_to_sql(con, "listing", listing_data)
    
    
    #################### Extract tables from database

}
```


### Data Loading

We can load the data from our database in either of the following ways: 

  1. As data frames

```{r}
host_info <- tbl(con, "host_info") %>% as.data.frame()
listing <- tbl(con, "listing") %>% as.data.frame()
```

  2. By querying the database

```{r}
# load host_info table 
res_host_info <- dbSendQuery(con, "select * from host_info")  
host_info <- fetch(res_host_info) 
dbClearResult(res_host_info)

# load listing table
res_listing <- dbSendQuery(con, "select * from listing")
listing <- fetch(res_listing)
dbClearResult(res_listing)
```


## Room Listing Queries

### Most Common Room Type Available

```{r}

```

### Top/Bottom Room Types Based on Average Price

```{r}

```

### Top/Bottom Room Types Based on Review Score

```{r}

```

### Most Common Amenities

```{r}

```

### Room Price Review Score Correlation

<center>  _Does paying a higher price for 'nicer' accommodations correlate to an increased satisfaction level?_ </center>


We notice that while an accommodation may only have one score in terms of price, it is reviewed among several different dimensions:

  1. Cleanliness
  2. Checkin
  3. Communication
  4. Location
  5. Rating
  6. Accuracy
  7. Value
  8. Overall Rating
  
We start by selecting the `price` and review related columns from the `listing` table, drop any rows that are missing review score, and filter out a spurious outlier. This leaves us with roughly 10,000 observations remaining, more than enough to theoretically examine correlation.

```{r}
q5 <- 
    listing %>% select(price, review_scores_accuracy, 
                       review_scores_cleanliness, review_scores_checkin, 
                       review_scores_communication, review_scores_location, 
                       review_scores_rating, review_scores_value) %>% 
                drop_na() %>% 
                filter(price != 13)
```

We defined the following function `c_plot()` to handle the repetitive plotting of price versus our eight different review dimensions.

```{r}
# Function defining correlation plot
c_plot <- function(df, y_val, y_name, clr = "dodgerblue4"){
    c_plot <- df %>% 
        ggplot(aes(x = price,
                   y = y_val)) +
            geom_jitter(color = clr, alpha = 0.5) + 
            scale_x_log10(label = scales::number_format(big.mark = ",")) +
            labs(x = "Price",
                 y = y_name,
                 title = y_name) + theme_tq()
    return(c_plot)
}
```

We then construct our correlation graphs using the above defined `c_plot()` function. We also use the `grid.arrange()` function from the `gridExtra` library to help align our multiple plots for parallel examination.

```{r}
# Colours for correlation plot
c <- c("Aquamarine4", "Sienna3")

# Build correlation plots
q5_1 <- c_plot(q5, q5$review_scores_rating, "Rating vs Price") 
q5_2 <- c_plot(q5, q5$review_scores_accuracy, "Accuracy", clr = c[1]) 
q5_3 <- c_plot(q5, q5$review_scores_cleanliness, "Cleanliness", clr = c[1]) 
q5_4 <- c_plot(q5, q5$review_scores_checkin, "Check-in", clr = c[1]) 
q5_5 <- c_plot(q5, q5$review_scores_communication, "Communication", clr = c[2]) 
q5_6 <- c_plot(q5, q5$review_scores_location, "Location", clr = c[2]) 
q5_7 <- c_plot(q5, q5$review_scores_value, "Value", clr = c[2]) 

# Output correlation plots
q5_1
grid.arrange(q5_2, q5_3, q5_4, ncol = 3)
grid.arrange(q5_5, q5_6, q5_7, ncol = 3)
```

Our plots appear noisy, and while we can see a consistent pattern between price and all eight dimensions along which accommodations are reviewed, we can statistically test the correlation by:

  1. Using the `cor.test()` function each combination of price and review score
  2. Extracting the test's confidence interval for each correlation test 
  3. Compiling the results into a table for further examination

```{r}
# Conduct numerical correlation test
c1 <- cor.test(q5$price, q5$review_scores_rating)
c2 <- cor.test(q5$price, q5$review_scores_accuracy)
c3 <- cor.test(q5$price, q5$review_scores_cleanliness)
c4 <- cor.test(q5$price, q5$review_scores_checkin)
c5 <- cor.test(q5$price, q5$review_scores_communication)
c6 <- cor.test(q5$price, q5$review_scores_location)
c7 <- cor.test(q5$price, q5$review_scores_value)

# Extract correlation test confidence intervals
c1_int <- paste0(round(c1$conf.int[1], 2), ", ", round(c1$conf.int[2], 2))
c2_int <- paste0(round(c2$conf.int[1], 2), ", ", round(c2$conf.int[2], 2))
c3_int <- paste0(round(c3$conf.int[1], 2), ", ", round(c3$conf.int[2], 2))
c4_int <- paste0(round(c4$conf.int[1], 2), ", ", round(c4$conf.int[2], 2))
c5_int <- paste0(round(c5$conf.int[1], 2), ", ", round(c5$conf.int[2], 2))
c6_int <- paste0(round(c6$conf.int[1], 2), ", ", round(c6$conf.int[2], 2))
c7_int <- paste0(round(c7$conf.int[1], 2), ", ", round(c7$conf.int[2], 2))

# Construct data frame of confidence intervals for correlation plots
confidence_intervals <- c(c1_int, c2_int, c3_int, c4_int, c5_int,
                          c6_int, c7_int)

review_category <- c("Rating", "Accuracy", "Cleanliness", "Check–in", 
                     "Communication", "Location", "Value")

correlation_df <- data.frame(review_category, confidence_intervals)
correlation_df %>% knitr::kable(align = c("c", "c"))
```

Looking at our final table, we see that all confidence intervals contain the value 0, which  we could interpret to mean that there is no significant correlation between room price and the review score. Users paying for cheap accommodations may be perfectly satisfied with their experience, while paying more does not necessarily guarantee you a higher level of satisfaction.

### Room Listing Geographical Distribution

```{r}

```



## Host Queries

### Who are the top 10 host based on revenue?

```{r}

```

### Is there any difference in review score between superhost and normal host?

```{r}

```


### Is there any difference in response rate between superhost and normal host?

```{r}

```

### What is the most commonly verified host information?

```{r}

```

### Most Active Months for New Host Sign-Up 

<center> _What months of the year have historically seen the most activity in terms of new hosts signing up for the service?_ </center>

We begin by extracting and isolating the necessary data using the following steps:

  1. Join together the two tables.
  2. Select the relevant columns.
  3. Convert `host_since_date` to the type `date` using the `as.Date()` function.
  4. Separate the `host_since` column into three separate columns for `Year`, `month` and `day` respectively.
  5. Discard the unnecessary `day` column.
  6. Group by `Year` and `Month` and use the `count()` function to tabulate the results.
  7. Construct the necessary columns for the resulting plot and table in the next step
  8. Disregard any rows containing `NA` values

```{r}
q11 <- 
    host_info %>%                                                     # 1
    left_join(listing, by = "host_id") %>% 
    select(host_id, host_since) %>%                                   # 2
    mutate(host_since_date = as.Date(host_since)) %>%                 # 3
    separate("host_since", c("Year", "Month", "Day"), sep = "-") %>%  # 4
    select(-Day) %>%                                                  # 5
    group_by(Year, Month) %>%                                         # 6
    count(Year, Month) %>% 
    ungroup() %>% 
    mutate(year_month = paste0(Year, "-", Month, "-", "01"),          # 7
           year_month_2 = paste0(Year, "-", Month), 
           joined = n) %>% 
    select(year_month, year_month_2, joined) %>% 
    mutate(year_month = as.Date(year_month)) %>% 
    drop_na()                                                         # 8
```

Next, we use the `ggplot` library's `geom_line()` function to plot the data as a time series.

```{r}
q11 %>%
    ggplot(aes(x = year_month, y = joined)) +
    geom_line(size = 1.2, colour = "Aquamarine4") + 
    scale_x_date(breaks = waiver(), date_breaks = "6 months") + theme_tq() + 
    theme(axis.text.x = element_text(angle = 45, face = "bold", vjust = 0.65),
          axis.text.y = element_text(face = "bold")) + 
    labs(
        title    = "Number of hosts joined",
        subtitle = "Shows the frequency rate at which new posts sign up for airbnb",
        caption  = "",
        x        = "Joined",
        y        = "Year/Month")
```

Since we are dealing with data over a number of years, it is helpful to also compile a list of the top 10 most active months in terms of new hosts

```{r}
q11 %>% 
    select(-year_month) %>% 
    mutate(year_month = as.yearmon(year_month_2)) %>% 
    select(-year_month_2) %>% 
    select(year_month, joined) %>% 
    arrange(desc(joined)) %>% 
    head(10) %>% knitr::kable(align = c("c", "c"))
```

We see that the summer months (June-August), especially in recent years, makeup almost all of the busiest months in terms of new hosts joining the service. Interestingly, December also has two months in the top 10.

